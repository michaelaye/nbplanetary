---

title: Geotools


keywords: fastai
sidebar: home_sidebar

summary: "Utilities to work with geo-referenced (image) data. (GDAL required)"
description: "Utilities to work with geo-referenced (image) data. (GDAL required)"
nb_path: "notebooks/08_geotools.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: notebooks/08_geotools.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Abbreviations">Abbreviations<a class="anchor-link" href="#Abbreviations"> </a></h2><ul>
<li>ul = Upper Left</li>
<li>lr = LowerRight</li>
</ul>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calculate_image_azimuth" class="doc_header"><code>calculate_image_azimuth</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L22" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calculate_image_azimuth</code>(<strong><code>origPoint</code></strong>, <strong><code>newPoint</code></strong>, <strong><code>zero</code></strong>=<em><code>'right'</code></em>)</p>
</blockquote>

<pre><code>Calculate azimuth angle between 2 image points.

Beware that this function calculates trigonometric angles.
If the points are from an image that has (0, 0) in the upper left, this means
that the angles increase clockwise.
That is why, for example, for an HiRISE image, the return of this function
matches the angle rotation definition for HiRISE data.

Parameters
==========
origPoint, newPoint: &lt;mars.Point&gt; objects
zero: &lt;string&gt;
    right' or 'top' to indicate where zero is.

Returns
=======
azimuth: &lt;float&gt;
    Azimuth angle</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_north_shifted_point" class="doc_header"><code>get_north_shifted_point</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L59" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_north_shifted_point</code>(<strong><code>img</code></strong>, <strong><code>offset</code></strong>=<em><code>0.001</code></em>)</p>
</blockquote>

<pre><code>Increasing the latitude is a sure way of getting north.</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="calculate_image_north_azimuth" class="doc_header"><code>calculate_image_north_azimuth</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L66" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>calculate_image_north_azimuth</code>(<strong><code>img</code></strong>, <strong><code>zero</code></strong>=<em><code>'right'</code></em>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_sun_angles" class="doc_header"><code>get_sun_angles</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L71" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_sun_angles</code>(<strong><code>spicer</code></strong>, <strong><code>img</code></strong>)</p>
</blockquote>

<pre><code>Calculate solar azimuth and incidence.

By requiring a spicer object for this function, it becomes independent from the
solar system object where the calculations are made.

Parameters
----------
spicer : spicer.Spicer
    needs to be setup for time, but spoint is set from img.center in here.
img : geotools.ImgData
    The image data of which the center point serves as the start point.

Returns
-------
tuple(float, float)
    Solar azimuth, incidence [degrees]</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="debug_srs" class="doc_header"><code>debug_srs</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L101" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>debug_srs</code>(<strong><code>projection</code></strong>)</p>
</blockquote>

<pre><code>Correct wrong scale_factor in PolarStereographic data.

Some PolarStereographic data have a 0 as a scale_factor in the
projection (mostly MOLA), which is being corrected here.
TODO: Check for being PolarStereographic before doing this!</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="shift_to_center" class="doc_header"><code>shift_to_center</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L114" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>shift_to_center</code>(<strong><code>x</code></strong>, <strong><code>y</code></strong>, <strong><code>geotransform</code></strong>)</p>
</blockquote>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="pixel_to_meter" class="doc_header"><code>pixel_to_meter</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L122" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>pixel_to_meter</code>(<strong><code>sample</code></strong>, <strong><code>line</code></strong>, <strong><code>geotransform</code></strong>, <strong><code>shift</code></strong>=<em><code>False</code></em>)</p>
</blockquote>

<pre><code>provide point in map projection coordinates.

Parameters
==========
sample, line: &lt;integer&gt; Sample and line of an image in pixel coords
Geotransform in format as given by GDAL datasets.GetGeoTransform()

Returns
=======
tuple (x,y) coordinates in the projection of the dataset

TODO: Shift had a problem. Write test to confirm what and fix.
FIXME above</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Point" class="doc_header"><code>class</code> <code>Point</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L143" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Point</code>(<strong><code>sample</code></strong>=<em><code>None</code></em>, <strong><code>line</code></strong>=<em><code>None</code></em>, <strong><code>x</code></strong>=<em><code>None</code></em>, <strong><code>y</code></strong>=<em><code>None</code></em>, <strong><code>lon</code></strong>=<em><code>None</code></em>, <strong><code>lat</code></strong>=<em><code>None</code></em>, <strong><code>geotrans</code></strong>=<em><code>None</code></em>, <strong><code>proj</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

<pre><code>Point class to manage pixel and map points and their transformations.

Parameters
==========
Either:
sample, line: pixel coordinates
or
x, y: projection coordinates (km or m)
or
lon, lat: geographical coordinates in degrees

Requires
========
gdal to enable sample/line&lt;-&gt; map coords tra'fo's

&gt;&gt;&gt; p = Point(0,1)

Need a dataset to try, so I get a MOLA dataset:
&gt;&gt;&gt; mola = MOLA()
&gt;&gt;&gt; '%4.2f, %4.2f' % p.pixel_to_meter(mola.dataset.GetGeoTransform())
'-707109.70, 706994.61'
&gt;&gt;&gt; p = Point(x=0,y=1)
&gt;&gt;&gt; '%4.2f, %4.2f' % p.meter_to_pixel(mola.dataset.GetGeoTransform())
'6144.00, 6143.99'
&gt;&gt;&gt; p2 = Point(x=3,y=3)
&gt;&gt;&gt; newP = p + p2
&gt;&gt;&gt; print(newP.x, newP.y)
3 4</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="Window" class="doc_header"><code>class</code> <code>Window</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L343" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>Window</code>(<strong><code>ulPoint</code></strong>=<em><code>None</code></em>, <strong><code>lrPoint</code></strong>=<em><code>None</code></em>, <strong><code>centerPoint</code></strong>=<em><code>None</code></em>, <strong><code>width</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

<pre><code>class to manage a window made of corner Points (objects of Point())

when using width, only quadratic windows supported currently
&gt;&gt;&gt; p1 = Point(0, 1)
&gt;&gt;&gt; p2 = Point(10,20)</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h2 id="ImgData" class="doc_header"><code>class</code> <code>ImgData</code><a href="https://github.com/michaelaye/nbplanetary/tree/master/planetarypy/geotools.py#L468" class="source_link" style="float:right">[source]</a></h2><blockquote><p><code>ImgData</code>(<strong><code>fname</code></strong>=<em><code>None</code></em>)</p>
</blockquote>

<pre><code>docstring for ImgData</code></pre>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#     &quot;&quot;&quot;combine CTX and MOLA data.</span>
<span class="c1">#</span>
<span class="c1">#     MOLA and CTX data will be combined with these tools.</span>
<span class="c1">#     User shall provide line,sample center coordinate of CTX file ROI to</span>
<span class="c1">#     define distance in meters from southpole.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     ctx = CTX(ctxFilename)</span>
<span class="c1">#     mola = MOLA()</span>
<span class="c1">#     ctxULsample, ctxULline, ctxLRsample, ctxLRline = \</span>
<span class="c1">#         get_corners_from_center(ctxSample, ctxLine, ctxWidth)</span>
<span class="c1">#     ulX,ulY = get_coords_from_pixels(ctxDS, ctxULsample, ctxULline)</span>
<span class="c1">#     lrX,lrY = get_coords_from_pixels(ctxDS, ctxLRsample, ctxLRline)</span>
<span class="c1">#</span>
<span class="c1">#     molaULsample,molaULline = get_pixels_from_coords(molaDS,ulX,ulY)</span>
<span class="c1">#     molaLRsample,molaLRline = get_pixels_from_coords(molaDS,lrX,lrY)</span>
<span class="c1">#     print(ctxULsample, ctxULline, ctxLRsample, ctxLRline)</span>
<span class="c1">#     print(molaULsample, molaULline,molaLRsample, molaLRline)</span>
<span class="c1">#     print(ulX,ulY,lrX,lrY)</span>
<span class="c1">#     ctxData = ctxDS.ReadAsArray(ctxULsample,ctxULline,ctxWidth,ctxWidth)</span>
<span class="c1">#     molaData = molaDS.ReadAsArray(int(molaULsample)+1,int(molaULline),</span>
<span class="c1">#                                   int(molaLRsample - molaULsample),</span>
<span class="c1">#                                   int(molaLRline - molaULline))</span>
<span class="c1">#</span>
<span class="c1">#     molaData = molaData - molaData.mean()</span>
<span class="c1">#</span>
<span class="c1">#     # x = np.arange(ulX,lrX)</span>
<span class="c1">#     # y = np.arange(lrY,ulY)</span>
<span class="c1">#     # X, Y = np.meshgrid(x,y)</span>
<span class="c1">#     # plotting</span>
<span class="c1">#     fig = plt.figure(figsize=(10,10))</span>
<span class="c1">#     ax = fig.add_subplot(111)</span>
<span class="c1">#     plt.gray()</span>
<span class="c1">#     ax.imshow(ctxData, extent=(min(ulX,lrX),max(ulX,lrX),min(ulY,lrY),</span>
<span class="c1">#                                      max(ulY,lrY)))</span>
<span class="c1">#     CS = ax.contour(molaData, 20, cmap = cm.jet,</span>
<span class="c1">#                      extent=(min(ulX,lrX),</span>
<span class="c1">#                              max(ulX,lrX),</span>
<span class="c1">#                              min(ulY,lrY),</span>
<span class="c1">#                              max(ulY,lrY)),</span>
<span class="c1">#                      origin=&#39;image&#39; )</span>
<span class="c1">#     plt.clabel(CS,fontsize=9, inline=1)</span>
<span class="c1">#     plt.show()</span>


<span class="c1"># def main(argv=None):</span>
<span class="c1">#     &quot;&quot;&quot;docstring for main&quot;&quot;&quot;</span>
<span class="c1">#     from mayavi import mlab</span>

<span class="c1">#     if argv is None:</span>
<span class="c1">#         argv = sys.argv</span>

<span class="c1">#     x1 = x2 = y1 = y2 = 0</span>
<span class="c1">#     fname = &quot;&quot;</span>
<span class="c1">#     try:</span>
<span class="c1">#         fname = argv[1]</span>
<span class="c1">#         x1, x2, y1, y2 = [int(i) for i in argv[2:]]</span>
<span class="c1">#     except:</span>
<span class="c1">#         print(&quot;Usage: {0} fname x1 x2 y1 y2&quot;.format(argv[0]))</span>

<span class="c1">#     print(x1, x2, y1, y2)</span>
<span class="c1">#     ds = gdal.Open(fname)</span>
<span class="c1">#     band = ds.GetRasterBand(1)</span>
<span class="c1">#     STORED_VALUE = band.ReadAsArray(x1, y1, x2 - x1, y2 - y1)</span>
<span class="c1">#     ds = 0</span>

<span class="c1">#     # PDS label infos:</span>
<span class="c1">#     SCALING_FACTOR = 0.25</span>
<span class="c1">#     OFFSET = -8000</span>
<span class="c1">#     topo = (STORED_VALUE * SCALING_FACTOR) + OFFSET</span>
<span class="c1">#     mlab.surf(topo, warp_scale=1 / 115.0, vmin=1700)</span>
<span class="c1">#     mlab.colorbar(orientation=&quot;vertical&quot;, title=&quot;Height [m]&quot;, label_fmt=&quot;%4.0f&quot;)</span>
<span class="c1">#     mlab.show()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

<script type="application/vnd.jupyter.widget-state+json">
{"state": {}, "version_major": 2, "version_minor": 0}
</script>

